# Projects Portfolio
# Table of Contents
- [AI Digit Recognizer](#ai-digit-recognizer)
- [Maproom](#maproom-campus-navigation-app)
- [ATV Repair Shop Database](#ms-access-atv-repair-shop-database)
- [Java Dodge Game](#java-dodge-game)
- [Unity AI Survival Agent](#unity-ai-survival-agent)
# AI Digit Recognizer
![Digit Recognizer 2](https://github.com/MyutVoilim/Projects-Portfolio/assets/54462267/b6f11075-d122-4dbc-96d6-03a7fa03f8d2)

<b>Technologies:</b> C# | WPF | .Net Framework | Visual Studio

<b>Overview:</b> This project is a built from scratch Feed-Forward Neural Network (FNN) that uses backpropigation to progressivly train a neural network from training data of drawn number 0 - 9. Following Object-oriented Programming (OOP) princables this project is meant to be the highlight of years of both academic and personal projects that takes a challenging concept and on goes through the software devlopment life cycle (SDLC) to plan, design, implement, test, and deploy a complex system. This application allows the user to create custome neural networks that they can train with a adjustable variables such as learning rate and epoch count. I was focused on not just creating a neural netowrk but a application that interactive, informative, and fun to use. 
o

<b>Features</b>
- Interactive digit recognition where the user can draw digits and see the AI's confidence values in real-time.
- Customizable neural network with the ability to create custom neural networks by defining hidden layer sizes and node counts.
- Control over training parameters such as ajusting learning rates and epoch counts to influence training route.
- User-friendly interface that includes dynamic visuals, progress bars, accuracy tracking, and confidence value displays.
- Ability to save and load models as well as change training data

<b>Introduction to Me and Proejct</b>

https://github.com/MyutVoilim/Projects-Portfolio/assets/54462267/df073c76-e715-49eb-9d00-9c8d300d937c

<b>Project Demo</b>

https://github.com/MyutVoilim/Projects-Portfolio/assets/54462267/197f9e12-64d2-480d-b767-73c9e4ce858b

<b>Challenges Overcome</b>
- <b>Comprehensive Design and Development:</b> Tackled the complexities of designing and implementing a neural network in C# with a strong emphasis on OOP.
- <b>Testing and Reliability:</b> Focused on unit testing to ensure reliability in complex processes, learning valuable lessons in bug detection and system robustness.
- <b>Documentation and Learning:</b> The project was not just a technical challenge but also an opportunity to refine my skills in creating comprehensive documentation and understanding the intricacies of neural network behaviors.

<b>A Little More In-Depth</b>
Due to the complex nature of neural networks, planning out the structure of the network itself as well as how the rest to the system would interact with it prooved more difficult than any other project I've made. It was imparative that I created a robust foundation to reduce bugs and improve testability for each section to check for excepted behavior. This process included implementing single responsability principles and dependency injection to allow for Unit testing expected funtionality. 

<b>Reflection</b>
This project was important for applying my knowledge to a difficult task and learning where I can improve, nothing is learned by taking it easy. I learned a lot about what makes code robustness, testability, and maintainability.


This is one of my most complex but satisfying projects into terms of both size and complexity. I found it very difficult to properly determine what strucutre I would need since i've never made a neural network this complex. Since i've never made a neural network this compelex I found myself a little unsure how excatly I should strucutre some the internal architecture of the network. Unlike most projects i've made before, nature of how many stages must be compeleted before any tangiable results from the network can be seen gave my many unique challenges from finding bugs and determineing the structure . The journey from data from a text file to the output and training of the neural network is a long and complex journey with a million things to go wrong it goes from (Data in Text file) > (coverted into proper format for neural netowork) > (netowrk weights and baised initalized) > (data normalized using sigmoid) > (Forward pass through network) > (output of the network) > (proccessing through backpropigation) > (finally outputed to the UI). Within this whole process a million things can go wrong from the text file being read wrong to very subtle bugs the mess with the training of the AI.
  
# Maproom Campus Navigation App
![Maproom Overview (1)](https://github.com/MyutVoilim/Projects-Portfolio/assets/54462267/b9516baa-0021-46bd-9d64-8f4a8ffba4a7)

<b>Technologies:</b> JavaScript | CSS | HTML5 | Node.js | JSON | MongoDB | Visual Studio Code

<b>Overview</b>
This project named Maproom is a collaboration between myself and two other students to create a Campus navigation app for our CS capstone project. The main focus was to create an app that would allow for mainly Freshman students comming into campus to more easily and less nervreckingly find their classes in time in unframiliar surrounding. The app shows various important building on the campus location alond with the ability for the user to searach for the class code such as CYBR 233, and find the building it is in and highlight the room location. Their was heavy important in the SDLC in all phases from planning out our requirments from what skills we had to surveys asked of new studnets to find what was most important to them in fidning their classes. Using technologies such as Github, Discord, and tools to create Gnatt charts were all used to collbtrativly to create this project.
Technologies Used


<b>Features</b>
- Provides user with the building and floor along with a highlight for the exact room they are look for.
- A campus view and local view for building and room locations
- Initiative search functionality that simplifies finding classroom without needing to know the exact building it is in

![Maproom Satellite View](https://github.com/MyutVoilim/Projects-Portfolio/assets/54462267/dfa1152e-a85c-42c2-9034-fa91ede7c13b)
![Maproom Searching room](https://github.com/MyutVoilim/Projects-Portfolio/assets/54462267/c78167d9-2236-491c-bdec-bcb538b7c4eb)


<b>Challenges Overcome</b>
- <b>Collaboration Across Disciplines:</b>  Our team had diverse backgrounds ranging from Business to Computer Science lending each with difference experiences that could be utilized with responsibilities divided based on our areas of expertise. I focused on database management, JavaScript logic for mapping, and developing the search engine.
- <b>Collaboration Across Disciplines:</b> Our team had diverse backgrounds ranging from Business to Computer Science lending each with difference experiences that could be utilized with responsibilities divided based on our areas of expertise. I focused on database management, JavaScript logic for mapping, and developing the search engine.
- <b>Time Management:</b> Balancing development with academic and work commitments. We utilized Gantt charts and meetings to hit weekly targets and had task prioritization.
- <b>Remote Coordination:</b> Leveraged tools like Discord, email, and GitHub for communication and version control, overcoming the challenge of coordinating work across different schedules.
- 
  <b>A Little More In-Depth</b>

  <b>Reflection</b>
  
  Because this project is a collaberation between three people it was important that we as a group determine what we wanted to create and the process we would use to achieve that. It was also important that we had a tangiable timeline the we ahchieved with a gnatt chart to assign tasks and keep us in line with are targets. using technolgoies like github to centralize and upload progress, Discord for communication when we couldn't not get together, and close collabration that utalized each of are backgrounds from busienss to computer science. Their were times when we could not get together because of scheduels but assigning ahead of time what each needed to to along with updates on where we were at allowed us to iterativly improve or application until the eventual creation.

  
# MS Access ATV Repair Shop Database
![3K Hub](https://github.com/MyutVoilim/Projects-Portfolio/assets/54462267/cf74f033-e55f-46e7-a208-ee95f5c04e78)
![3K Full Service View](https://github.com/MyutVoilim/Projects-Portfolio/assets/54462267/fe160030-9372-49b9-932e-d7480bb8c224)

<b>Technologies:</b>Microsoft Access

<b>Overview</b>
A relational database crafted to streamline operations for an ATV repair shop. Meant to replace their cumbersome physical logging system with a user friends system that allows the client to quickly find customers and their associated repairs.


<b>Features</b>
- Customer information management to quickly store and retrieve customer details
- Logging of ATV vehicle information, Repairs, and other services
- Easy navigation from customer to associated ATVs or ATVs to associated customers.
- Ability to print forms for physical backups

![3K Customer List](https://github.com/MyutVoilim/Projects-Portfolio/assets/54462267/96d62058-4aed-4561-b1f6-358066148ef3)
![3K Repairs](https://github.com/MyutVoilim/Projects-Portfolio/assets/54462267/64cf73f6-ddca-4bab-84ac-23b5ec7240de)


<b>Challenges Overcome</b>
- <b>Client Collaboration:</b> Worked closely with the client to ensure the system met their specific needs. Involved in extensive planning and iterative feedback sessions to fine-tune the system's features and functionalities.
- <b>Business Requirements Analysis:</b> Focused on aligning the database design with the practical business requirements of the repair shop.
- <b>System Design and Presentation:</b> Carefully designed the system with an emphasis on usability, and actively involved the client in the design process to incorporate their feedback and additional functionality requirements.

  <b>A Little More In-Depth</b>

  <b>Reflection</b>


Challenges
Unlike most projects i've made, this one had real impact on someones life and how they operated their business. Their is something speicial about working with real issues and devloping software to make peoples lives easier. It was paramount that focused on the clients needs rather than to just create something I thought they wanted. I needed to make sure that I properly planned for what the client needed and continuously update them and adjust as needed based on those needs. Working for the client brings special challenges but is it one of the most rewards aspects about software devlopment

# Java Dodge Game
![Dodge Playing](https://github.com/MyutVoilim/Projects-Portfolio/assets/54462267/46014cea-276f-4c9a-a455-9cb8789e29d7)

<b>Technologies:</b> Java | Eclipse

<b>Overview</b>
Using Java and OOP to create a fun game where the user is meant to dodge red hazrard balls and collect as many green balls as possible. With various modes including easy, medium, hard, and insane, this challangeing game progressivly gets harder as more green balls are collected. Each mode chages a variety of variables from how quickly new hazard red balls are created, their speed, and their size. This application keeps track of the users current score and the highest scores they've achieved on each mode.

<b>Features</b>
- Various gamemodes that change progression and difficulty
- Tracking for Highscore in each mode
- Ability to save and load highscores

![Dodge Highscore](https://github.com/MyutVoilim/Projects-Portfolio/assets/54462267/b901bd3f-79ae-43af-912d-a7125d1ff0a9)

<b>Challenges</b>
- <b>User Feedback:</b> adjusting variables for each mode (easy, medium, hard, insane) to ensure a fair yet challenging gameplay experience. Involving fine-tuning the spawn rate, speed, and size of the hazard balls based on a test groups feedback.
- <b>Smooth and Intuative Gameplay:</b> Ensuring the game runs smoothly without lag for quick reflex reaction and creating intuative self-explanitory design.
- <b>Effective Use of OOP:</b> Maintaining a clean, modular codebase using OOP principles such as encapsulation, inheritance, and polymorphism.

# Unity AI Survival Agent
![together](https://github.com/MyutVoilim/Projects-Portfolio/assets/54462267/00130ce1-471b-4a97-af2f-f037719e5e79)

<b>Technologies</b> C# | Unity | Visual Studio

<b>Overview</b>
This project uses C# and Unity to create an AI agent that generationally improves its survivability using a basic feed-forward neutral network in conjunction with a genetic algorithm. Each agent has several stats the determine variables like speed, visions range, vision cone count, and stamina that all affect the agents ability to find and compete for food in it's environment. Several agents are be pitted against each other with the agent that lived the longest having its genetics passed on to the next with slight mutations to futher hone a progressivly competetive agent.

<b>Features</b>
- Control over agent stats and environment such as how quickly stamina drains, food availability, and agent spawn count to increase or decrease competition
- Adjustable mutation rate to control how drastically children of the orginal agent will diverge
- Toggleability of certain agent features such a whether increase vision or movement speed drain stamina faster
- Ability to save/load AI models

  ![bigger](https://github.com/MyutVoilim/Projects-Portfolio/assets/54462267/077317d9-8d95-4599-b483-f621157f8b20)


<b>Challenges</b>
- <b>Learning a new platform:</b>This is the first project were I used Unity which intnially slowed down devlopment, but through documentation adn demoing functinality I was able to learn and Utalize Unity's framework.
- <b>Determining a proper reward system</b>Since this was a neural network it was neccessary to determine effective metrics for what would be concidred a successful agent, in my case I used time instead of amout of food captured since an agent may eat a lot of food but burn through stamina quickly compared to a slower more effecient agent.
- <b>Balancing agent abilities</b> Find tuning how much having large vision cone or speed should effect the agents stamina to create a copmetitive environment that allowed for multiple unique routes instead of just get fast and see farther.


